#include "pch.h"
#include <iostream>
#include <fstream>
#include <array>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <functional>
#include <sstream>
#include <list>

using namespace std;

class Path {

	list<char> lst = { '.', '.', '.' };
	list<char> startList = { '.', 'S', '.' };
	list<char> endList = { '.', 'E', '.' };
	list<char> wallList = { 'X', 'X', 'X' };
	list<char> ::iterator it = lst.begin();

	protected: bool start;
	protected: bool end;
	protected: bool blocked;


	public: Path() {
		// Fills the contList with the default start character '.'
		for (int i = 0; i < 3; i++) {
			lst.assign(i, '.');
		}
		start = false;
		end = false;
		blocked = false;
	}

	public: Path(char brand) {
		for (int i = 0; i < 3; i++) {
			// Checks to see if a wall exists and assigns 'X'
			if (brand == 'X' || brand == 'x') { // Converts to all Caps

				lst.assign(i, 'X');
				blocked = true;
			}
			// if no wall assign '.'
			else {

				lst.assign(i, '.');
			}	
		}

		// Start position assignment
		if (brand == 'S' || brand == 's') { // Converts to all Caps

			lst.insert(it, 'S');

			start = true;
		}
		// End possition assignment
		else if (brand == 'E' || brand == 'e') { // Converts to all Caps

			lst.insert(it, 'E');
			end = true;
		}
	}

	public: void SetBrand(char brand) {
		for (int i = 0; i < 3; i++) {
			// Checks to see if a wall exists and assigns 'X'
			if (brand == 'X' || brand == 'x') { // Converts to all Caps

				lst.assign(i, 'X');
				blocked = true;
			}
			// if no wall assign '.'
			else {

				lst.assign(i, '.');
			}
		}

		// Start position assignment
		if (brand == 'S' || brand == 's') { // Converts to all Caps

			lst.insert(it, 'S');

			start = true;
		}
		// End possition assignment
		else if (brand == 'E' || brand == 'e') { // Converts to all Caps

			lst.insert(it, 'E');
			end = true;
		}
	}
	char ReturnBrand(int row, int col) {
	
		for (int i = 0; i < row; i++) {
			for (int j = 0; j < col; j++) {
				for (auto v : lst) {
					return v;
				}
			}
		}
	}
};

void ShowMaze(Path ** maze, int rowSize, int colSize) {

	for (int i = 0; i < colSize; i++) {
		if (i < 10) {
			cout << "   " << i << "  ";
		}
		else {
			cout << "   " << i << " ";
		}
	}

	cout << endl;

	for (int n = 0; n < 3; n++) {
			for (int i = 0; i < rowSize; i++) {
				for (int m = 0; m < colSize; m++) {
					cout << (*maze).ReturnBrand(m, n); // why wont this work
				}
				cout << endl;
			}
	}
}


int main() {
	cout << endl;

	int startRow;
	int startCol;

	int colSize;
	int rowSize;

	int wallRow;
	int wallCol;

	int endRow;
	int endCol;

	colSize = 12;
	rowSize = 5;


	


	return 0;
}